{
  "version": 3,
  "file": "auth_token.js",
  "sourceRoot": "..",
  "sources": [
    "src/auth_token.coffee"
  ],
  "names": [],
  "mappings": "AAAA;;;;;;;;;AAAA,IAAA,MAAA,EAAA,MAAA,EAAA,MAAA,EAAA;;AAIA,MAAA,GAAS,OAAA,CAAQ,QAAR;;AACT,MAAA,GAAS,OAAA,CAAQ,UAAR;;AAET,MAAA,GAAS,QAAA,CAAC,OAAD,EAAU,GAAV,CAAA;SACP,MAAM,CAAC,UAAP,CAAkB,QAAlB,EAA4B,IAAI,MAAJ,CAAW,GAAX,EAAgB,KAAhB,CAA5B,CAAmD,CAAC,MAApD,CAA4D,OAA5D,CAAoE,CAAC,MAArE,CAA4E,KAA5E;AADO;;AAQT,eAAA,GAAkB,QAAA,CAAC,GAAD,CAAA;SAChB,kBAAA,CAAmB,GAAnB,CAAuB,CAAC,OAAxB,CAAgC,MAAhC,EAAwC,QAAA,CAAC,KAAD,CAAA;WAAU,KAAK,CAAC,WAAN,CAAA;EAAV,CAAxC;AADgB,EAflB;;;;;;;;;;;;;;AA8BA,MAAM,CAAC,OAAP,GAAiB,QAAA,CAAC,OAAD,CAAA;AACf,MAAA,IAAA,EAAA,IAAA,EAAA,GAAA,EAAA,IAAA,EAAA,KAAA,EAAA,MAAA,EAAA,SAAA,EAAA,UAAA,EAAA;EAAA,SAAA,8CAAiC;EAEjC,IAAO,0BAAP;IACE,IAAG,wBAAH;MACE,KAAA,gDAA6B,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,GAAL,CAAA,CAAA,GAAa,IAAxB;MAC7B,OAAO,CAAC,UAAR,GAAqB,KAAA,GAAQ,OAAO,CAAC,SAFvC;KAAA,MAAA;MAIE,MAAM,IAAI,KAAJ,CAAW,4CAAX,EAJR;KADF;;EAOA,UAAA,GAAa;EACb,IAAuC,kBAAvC;IAAA,UAAU,CAAC,IAAX,CAAgB,CAAA,GAAA,CAAA,CAAM,OAAO,CAAC,EAAd,CAAA,CAAhB,EAAA;;EACA,IAA+C,0BAA/C;IAAA,UAAU,CAAC,IAAX,CAAgB,CAAA,GAAA,CAAA,CAAM,OAAO,CAAC,UAAd,CAAA,CAAhB,EAAA;;EACA,UAAU,CAAC,IAAX,CAAgB,CAAA,IAAA,CAAA,CAAO,OAAO,CAAC,UAAf,CAAA,CAAhB;EACA,IAA0D,mBAA1D;IAAA,UAAU,CAAC,IAAX,CAAgB,CAAA,IAAA,CAAA,CAAO,eAAA,CAAgB,OAAO,CAAC,GAAxB,CAAP,CAAA,CAAhB,EAAA;;EACA,MAAA;;AAAe;IAAA,KAAA,4CAAA;;mBAAL;IAAK,CAAA;;;EACf,IAAG,OAAO,CAAC,GAAX;IACE,GAAA,GAAM,eAAA,CAAgB,OAAO,CAAC,GAAxB;IACN,MAAM,CAAC,IAAP,CAAY,CAAA,IAAA,CAAA,CAAO,GAAP,CAAA,CAAZ,EAFF;;EAGA,IAAA,GAAO,MAAA,CAAO,MAAM,CAAC,IAAP,CAAY,GAAZ,CAAP,EAAyB,OAAO,CAAC,GAAjC;EACP,UAAU,CAAC,IAAX,CAAgB,CAAA,KAAA,CAAA,CAAQ,IAAR,CAAA,CAAhB;SACA,CAAA,CAAA,CAAG,SAAH,CAAa,CAAb,CAAA,CAAgB,UAAU,CAAC,IAAX,CAAgB,GAAhB,CAAhB,CAAA;AArBe",
  "sourcesContent": [
    "###*\n  * Authorization Token\n  * @module auth_token\n###\ncrypto = require('crypto')\nconfig = require('./config')\n\ndigest = (message, key) ->\n  crypto.createHmac(\"sha256\", new Buffer(key, \"hex\")).update( message).digest('hex')\n\n###*\n  * Escape url using lowercase hex code\n  * @param {string} url a url string\n  * @return escaped url\n###\nescape_to_lower = (url) ->\n  encodeURIComponent(url).replace(/%../g, (match)-> match.toLowerCase())\n\n###*\n  * Generate an authorization token\n  * @param {Object} options\n  * @param {string} options.key - the secret key required to sign the token\n  * @param {string} [options.ip] - the IP address of the client\n  * @param {number} [options.start_time=now] - the start time of the token in seconds from epoch\n  * @param {string} [options.expiration] - the expiration time of the token in seconds from epoch\n  * @param {string} [options.duration] - the duration of the token (from start_time)\n  * @param {string} [options.acl] - the ACL for the token\n  * @param {string} [options.url] - the URL to authentication in case of a URL token\n  * @returns {string} the authorization token\n###\nmodule.exports = (options)->\n  tokenName = options.token_name ? \"__cld_token__\"\n\n  unless options.expiration?\n    if options.duration?\n      start = options.start_time ? Math.round(Date.now() / 1000)\n      options.expiration = start + options.duration\n    else\n      throw new Error( \"Must provide either expiration or duration\")\n\n  tokenParts = []\n  tokenParts.push(\"ip=#{options.ip}\") if options.ip?\n  tokenParts.push(\"st=#{options.start_time}\") if options.start_time?\n  tokenParts.push(\"exp=#{options.expiration}\")\n  tokenParts.push(\"acl=#{escape_to_lower(options.acl)}\") if options.acl?\n  toSign = (part for part in tokenParts)\n  if options.url\n    url = escape_to_lower(options.url)\n    toSign.push \"url=#{url}\"\n  auth = digest(toSign.join(\"~\"), options.key)\n  tokenParts.push(\"hmac=#{auth}\")\n  \"#{tokenName}=#{tokenParts.join('~')}\"\n"
  ]
}